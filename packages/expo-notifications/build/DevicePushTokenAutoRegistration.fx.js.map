{"version":3,"file":"DevicePushTokenAutoRegistration.fx.js","sourceRoot":"","sources":["../src/DevicePushTokenAutoRegistration.fx.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,UAAU,EAAE,QAAQ,EAAE,MAAM,kBAAkB,CAAC;AACxD,OAAO,KAAK,WAAW,MAAM,kBAAkB,CAAC;AAEhD,OAAO,wBAAwB,MAAM,4BAA4B,CAAC;AAClE,OAAO,EAAE,oBAAoB,EAAE,MAAM,gBAAgB,CAAC;AAWtD;;;;GAIG;AACH,MAAM,CAAC,KAAK,UAAU,8BAA8B,CAAC,YAA0B;IAC7E,MAAM,wBAAwB,CAAC,4BAA4B,EAAE,CAAC,IAAI,CAAC,SAAS,CAAC,YAAY,CAAC,CAAC,CAAC;AAC9F,CAAC;AAED;;;GAGG;AACH,MAAM,CAAC,KAAK,UAAU,iCAAiC;IACrD,MAAM,wBAAwB,CAAC,4BAA4B,EAAE,CAAC,IAAI,CAAC,CAAC;AACtE,CAAC;AAED,4DAA4D;AAC5D,+BAA+B;AAC/B,oBAAoB,CAAC,KAAK,CAAC,EAAE;IAC3B,KAAK,CAAC,GAAG,EAAE,CAAC,oBAAoB,CAAC,KAAK,CAAC,EAAE,GAAG,EAAE,IAAI,GAAG,EAAE,GAAG,CAAC,CAAC,CAAC;AAC/D,CAAC,CAAC,CAAC;AAEH,IAAI,gBAAgB,GAAuB,SAAS,CAAC;AACrD,SAAS,KAAK,CAAC,EAA0B,EAAE,KAAa,EAAE,QAAgB;IACxE,IAAI,gBAAgB,EAAE;QACpB,YAAY,CAAC,gBAAgB,CAAC,CAAC;KAChC;IACD,EAAE,EAAE,CAAC,KAAK,CAAC,KAAK,CAAC,EAAE;QACjB,OAAO,CAAC,IAAI,CACV,oFAAoF,EACpF,KAAK,CACN,CAAC;QAEF,mDAAmD;QACnD,qEAAqE;QACrE,IACE,KAAK,YAAY,UAAU;YAC1B,KAAoB,CAAC,IAAI,KAAK,iCAAiC,EAChE;YACA,oEAAoE;YACpE,gBAAgB,GAAG,UAAU,CAC3B,GAAG,EAAE,CAAC,KAAK,CAAC,EAAE,EAAE,IAAI,CAAC,GAAG,CAAC,KAAK,GAAG,CAAC,EAAE,QAAQ,CAAC,EAAE,QAAQ,CAAC,EACxD,KAAK,CACN,CAAC;SACH;IACH,CAAC,CAAC,CAAC;AACL,CAAC;AAED,KAAK,UAAU,oBAAoB,CAAC,KAAsB;IACxD,gEAAgE;IAChE,MAAM,oBAAoB,GAAG,MAAM,wBAAwB,CAAC,4BAA4B,EAAE,EAAE,CAAC;IAC7F,wCAAwC;IACxC,IAAI,CAAC,oBAAoB,EAAE;QACzB,OAAO;KACR;IAED,uBAAuB;IACvB,MAAM,gBAAgB,GAAiB,IAAI,CAAC,KAAK,CAAC,oBAAoB,CAAC,CAAC;IACxE,MAAM,IAAI,GAAG;QACX,GAAG,gBAAgB,CAAC,IAAI;QACxB,4CAA4C;QAC5C,oDAAoD;QACpD,qDAAqD;QACrD,oDAAoD;QACpD,yDAAyD;QACzD,sCAAsC;QACtC,WAAW,EAAE,MAAM,uCAAuC,EAAE;QAC5D,WAAW,EAAE,KAAK,CAAC,IAAI;QACvB,IAAI,EAAE,cAAc,CAAC,KAAK,CAAC;KAC5B,CAAC;IAEF,cAAc;IACd,MAAM,KAAK,CAAC,gBAAgB,CAAC,GAAG,EAAE;QAChC,MAAM,EAAE,MAAM;QACd,OAAO,EAAE;YACP,cAAc,EAAE,kBAAkB;SACnC;QACD,IAAI,EAAE,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC;KAC3B,CAAC,CAAC,KAAK,CAAC,KAAK,CAAC,EAAE;QACf,MAAM,IAAI,UAAU,CAClB,iCAAiC,EACjC,iEAAiE,KAAK,GAAG,CAC1E,CAAC;IACJ,CAAC,CAAC,CAAC;AACL,CAAC;AAED,mCAAmC;AACnC,SAAS,cAAc,CAAC,eAAgC;IACtD,QAAQ,eAAe,CAAC,IAAI,EAAE;QAC5B,KAAK,KAAK;YACR,OAAO,MAAM,CAAC;QAChB,KAAK,SAAS;YACZ,OAAO,KAAK,CAAC;QACf,gFAAgF;QAChF;YACE,OAAO,eAAe,CAAC,IAAI,CAAC;KAC/B;AACH,CAAC;AAED,mCAAmC;AACnC,KAAK,UAAU,uCAAuC;IACpD,IAAI,QAAQ,CAAC,EAAE,KAAK,KAAK,EAAE;QACzB,IAAI;YACF,MAAM,8BAA8B,GAAG,MAAM,WAAW,CAAC,6CAA6C,EAAE,CAAC;YACzG,IAAI,8BAA8B,KAAK,aAAa,EAAE;gBACpD,OAAO,IAAI,CAAC;aACb;SACF;QAAC,OAAO,CAAC,EAAE;YACV,2DAA2D;SAC5D;KACF;IAED,OAAO,KAAK,CAAC;AACf,CAAC","sourcesContent":["import { CodedError, Platform } from '@unimodules/core';\nimport * as Application from 'expo-application';\n\nimport ServerRegistrationModule from './ServerRegistrationModule';\nimport { addPushTokenListener } from './TokenEmitter';\nimport { DevicePushToken } from './Tokens.types';\n\n/**\n * Encapsulates device server registration data\n */\nexport type Registration = {\n  url: string;\n  body: Record<string, any>;\n};\n\n/**\n * Sets the last registration information so that the device push token\n * gets pushed to the given registration endpoint\n * @param registration Registration endpoint to inform of new tokens\n */\nexport async function setAutoServerRegistrationAsync(registration: Registration) {\n  await ServerRegistrationModule.setLastRegistrationInfoAsync?.(JSON.stringify(registration));\n}\n\n/**\n * Removes last Expo server registration, future device push token\n * updates won't get sent there anymore.\n */\nexport async function removeAutoServerRegistrationAsync() {\n  await ServerRegistrationModule.setLastRegistrationInfoAsync?.(null);\n}\n\n// A global scope (to get all the updates) device push token\n// subscription, never cleared.\naddPushTokenListener(token => {\n  retry(() => updatePushTokenAsync(token), 500, 1000 * 60 * 2);\n});\n\nlet nextTryTimeoutId: number | undefined = undefined;\nfunction retry(fn: () => Promise<unknown>, delay: number, maxDelay: number) {\n  if (nextTryTimeoutId) {\n    clearTimeout(nextTryTimeoutId);\n  }\n  fn().catch(error => {\n    console.warn(\n      '[expo-notifications] Error encountered while updating device push token in server:',\n      error\n    );\n\n    // We only want to retry if it was a network error.\n    // Other error may be JSON.parse error which we can do nothing about.\n    if (\n      error instanceof CodedError &&\n      (error as CodedError).code === 'ERR_NOTIFICATIONS_NETWORK_ERROR'\n    ) {\n      // @ts-ignore: TS can't decide whether to use Node types or RN types\n      nextTryTimeoutId = setTimeout(\n        () => retry(fn, Math.min(delay * 2, maxDelay), maxDelay),\n        delay\n      );\n    }\n  });\n}\n\nasync function updatePushTokenAsync(token: DevicePushToken) {\n  // Fetch the latest registration info from the persisted storage\n  const lastRegistrationInfo = await ServerRegistrationModule.getLastRegistrationInfoAsync?.();\n  // If there is none, do not to anything.\n  if (!lastRegistrationInfo) {\n    return;\n  }\n\n  // Prepare request body\n  const lastRegistration: Registration = JSON.parse(lastRegistrationInfo);\n  const body = {\n    ...lastRegistration.body,\n    // Information whether a token is applicable\n    // to development or production notification service\n    // should never be persisted as it can change between\n    // Xcode development and TestFlight/AppStore without\n    // backing store being resetted (development registration\n    // remains in production environment).\n    development: await shouldUseDevelopmentNotificationService(),\n    deviceToken: token.data,\n    type: getTypeOfToken(token),\n  };\n\n  // Do register\n  await fetch(lastRegistration.url, {\n    method: 'POST',\n    headers: {\n      'content-type': 'application/json',\n    },\n    body: JSON.stringify(body),\n  }).catch(error => {\n    throw new CodedError(\n      'ERR_NOTIFICATIONS_NETWORK_ERROR',\n      `Error encountered while updating device push token in server: ${error}.`\n    );\n  });\n}\n\n// Same as in getExpoPushTokenAsync\nfunction getTypeOfToken(devicePushToken: DevicePushToken) {\n  switch (devicePushToken.type) {\n    case 'ios':\n      return 'apns';\n    case 'android':\n      return 'fcm';\n    // This probably will error on server, but let's make this function future-safe.\n    default:\n      return devicePushToken.type;\n  }\n}\n\n// Same as in getExpoPushTokenAsync\nasync function shouldUseDevelopmentNotificationService() {\n  if (Platform.OS === 'ios') {\n    try {\n      const notificationServiceEnvironment = await Application.getIosPushNotificationServiceEnvironmentAsync();\n      if (notificationServiceEnvironment === 'development') {\n        return true;\n      }\n    } catch (e) {\n      // We can't do anything here, we'll fallback to false then.\n    }\n  }\n\n  return false;\n}\n"]}