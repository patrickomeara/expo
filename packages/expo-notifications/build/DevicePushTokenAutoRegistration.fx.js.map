{"version":3,"file":"DevicePushTokenAutoRegistration.fx.js","sourceRoot":"","sources":["../src/DevicePushTokenAutoRegistration.fx.ts"],"names":[],"mappings":"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","sourcesContent":["import { CodedError, Platform } from '@unimodules/core';\nimport * as Application from 'expo-application';\n\nimport ServerRegistrationModule from './ServerRegistrationModule';\nimport { addPushTokenListener } from './TokenEmitter';\nimport { DevicePushToken } from './Tokens.types';\nimport generateRetries from './utils/generateRetries';\n\n/**\n * Encapsulates device server registration data\n */\nexport type Registration = {\n  url: string;\n  body: Record<string, any>;\n  pendingDevicePushToken?: DevicePushToken | null;\n};\n\n/**\n * Sets the last registration information so that the device push token\n * gets pushed to the given registration endpoint\n * @param registration Registration endpoint to inform of new tokens\n */\nexport async function setAutoServerRegistrationAsync(\n  registration: Omit<Registration, 'pendingDevicePushToken'>\n) {\n  await ServerRegistrationModule.setLastRegistrationInfoAsync?.(JSON.stringify(registration));\n}\n\n/**\n * Removes last Expo server registration, future device push token\n * updates won't get sent there anymore.\n */\nexport async function removeAutoServerRegistrationAsync() {\n  await ServerRegistrationModule.setLastRegistrationInfoAsync?.(null);\n}\n\n// Verify if last persisted registration\n// has successfully uploaded last known\n// device push token. If not, retry.\nServerRegistrationModule.getLastRegistrationInfoAsync?.().then(lastRegistrationInfo => {\n  if (!lastRegistrationInfo) {\n    // No last registration info, nothing to do\n    return;\n  }\n  try {\n    const lastRegistration: Registration = JSON.parse(lastRegistrationInfo);\n    if (lastRegistration?.pendingDevicePushToken) {\n      updatePushTokenAsync(lastRegistration.pendingDevicePushToken);\n    }\n  } catch (e) {\n    console.warn(\n      '[expo-notifications] Error encountered while fetching last registration information for auto token updates.',\n      e\n    );\n  }\n});\n\n// A global scope (to get all the updates) device push token\n// subscription, never cleared.\naddPushTokenListener(token => {\n  // Dispatch an abortable task to update\n  // last registration with new token.\n  updatePushTokenAsync(token);\n});\n\nasync function updatePushTokenAsync(token: DevicePushToken) {\n  // Fetch the latest registration info from the persisted storage\n  const lastRegistrationInfo = await ServerRegistrationModule.getLastRegistrationInfoAsync?.();\n  // If there is none, do not do anything.\n  if (!lastRegistrationInfo) {\n    return;\n  }\n\n  // Prepare request body\n  const lastRegistration: Registration = JSON.parse(lastRegistrationInfo);\n  // Persist `pendingDevicePushToken` in case the app gets killed\n  // before we finish registering to server.\n  await ServerRegistrationModule.setLastRegistrationInfoAsync?.(\n    JSON.stringify({\n      ...lastRegistration,\n      pendingDevicePushToken: token,\n    })\n  );\n\n  const body = {\n    ...lastRegistration.body,\n    // Information whether a token is applicable\n    // to development or production notification service\n    // should never be persisted as it can change between\n    // Xcode development and TestFlight/AppStore without\n    // backing store being resetted (development registration\n    // remains in production environment).\n    development: await shouldUseDevelopmentNotificationService(),\n    deviceToken: token.data,\n    type: getTypeOfToken(token),\n  };\n\n  const retriesIterator = generateRetries(async retry => {\n    try {\n      await fetch(lastRegistration.url, {\n        method: 'POST',\n        headers: {\n          'content-type': 'application/json',\n        },\n        body: JSON.stringify(body),\n      }).catch(error => {\n        throw new CodedError(\n          'ERR_NOTIFICATIONS_NETWORK_ERROR',\n          `Error encountered while updating device push token in server: ${error}.`\n        );\n      });\n    } catch (e) {\n      console.warn(\n        '[expo-notifications] Error thrown while updating device push token in server:',\n        e\n      );\n\n      // We only want to retry if it was a network error.\n      // Other error may be JSON.parse error which we can do nothing about.\n      if (e instanceof CodedError && (e as CodedError).code === 'ERR_NOTIFICATIONS_NETWORK_ERROR') {\n        retry();\n      } else {\n        // If we aren't going to try again, throw the error\n        throw e;\n      }\n    }\n  });\n\n  let result = await retriesIterator.next();\n  while (!result.done) {\n    result = await retriesIterator.next(result);\n  }\n\n  // We uploaded the token successfully, let's clear the `lastPushedToken`\n  // from the registration so that we don't try to upload the same token\n  // again.\n  await ServerRegistrationModule.setLastRegistrationInfoAsync?.(\n    JSON.stringify({\n      ...lastRegistration,\n      lastPushedToken: null,\n    })\n  );\n}\n\n// Same as in getExpoPushTokenAsync\nfunction getTypeOfToken(devicePushToken: DevicePushToken) {\n  switch (devicePushToken.type) {\n    case 'ios':\n      return 'apns';\n    case 'android':\n      return 'fcm';\n    // This probably will error on server, but let's make this function future-safe.\n    default:\n      return devicePushToken.type;\n  }\n}\n\n// Same as in getExpoPushTokenAsync\nasync function shouldUseDevelopmentNotificationService() {\n  if (Platform.OS === 'ios') {\n    try {\n      const notificationServiceEnvironment = await Application.getIosPushNotificationServiceEnvironmentAsync();\n      if (notificationServiceEnvironment === 'development') {\n        return true;\n      }\n    } catch (e) {\n      // We can't do anything here, we'll fallback to false then.\n    }\n  }\n\n  return false;\n}\n"]}